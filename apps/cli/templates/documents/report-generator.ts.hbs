{{#if typescript}}
import type { 
  ReportData,
  ReportType,
  ChartData,
  TableData,
  ReportSection
} from '../types/reports';
{{/if}}
import { PDFDocument, StandardFonts, rgb } from 'pdf-lib';
import { createCanvas } from 'canvas';
import Chart from 'chart.js/auto';

/**
 * Report Generator for {{projectName}}
 * Creates professional business reports with charts and Norwegian formatting
 */
export class ReportGenerator {
  private readonly translations = {
    nb: {
      // Report types
      financialReport: 'Finansrapport',
      complianceReport: 'Etterlevelsesrapport',
      auditReport: 'Revisjonsrapport',
      salesReport: 'Salgsrapport',
      inventoryReport: 'Lagerrapport',
      hrReport: 'HR-rapport',
      customReport: 'Tilpasset rapport',
      
      // Common terms
      period: 'Periode',
      from: 'Fra',
      to: 'Til',
      summary: 'Sammendrag',
      details: 'Detaljer',
      total: 'Total',
      subtotal: 'Delsum',
      average: 'Gjennomsnitt',
      count: 'Antall',
      percentage: 'Prosent',
      
      // Time periods
      daily: 'Daglig',
      weekly: 'Ukentlig',
      monthly: 'Månedlig',
      quarterly: 'Kvartalsvis',
      yearly: 'Årlig',
      
      // Metadata
      confidential: 'Konfidensielt',
      internal: 'Intern',
      public: 'Offentlig',
      secret: 'Hemmelig',
      page: 'Side',
      of: 'av',
      generatedOn: 'Generert',
      generatedBy: 'Generert av',
      author: 'Forfatter',
      department: 'Avdeling',
      approvedBy: 'Godkjent av',
      
      // Chart labels
      revenue: 'Inntekter',
      expenses: 'Utgifter',
      profit: 'Fortjeneste',
      growth: 'Vekst',
      target: 'Mål',
      actual: 'Faktisk',
      forecast: 'Prognose',
      budget: 'Budsjett'
    },
    en: {
      // Report types
      financialReport: 'Financial Report',
      complianceReport: 'Compliance Report',
      auditReport: 'Audit Report',
      salesReport: 'Sales Report',
      inventoryReport: 'Inventory Report',
      hrReport: 'HR Report',
      customReport: 'Custom Report',
      
      // Common terms
      period: 'Period',
      from: 'From',
      to: 'To',
      summary: 'Summary',
      details: 'Details',
      total: 'Total',
      subtotal: 'Subtotal',
      average: 'Average',
      count: 'Count',
      percentage: 'Percentage',
      
      // Time periods
      daily: 'Daily',
      weekly: 'Weekly',
      monthly: 'Monthly',
      quarterly: 'Quarterly',
      yearly: 'Yearly',
      
      // Metadata
      confidential: 'Confidential',
      internal: 'Internal',
      public: 'Public',
      secret: 'Secret',
      page: 'Page',
      of: 'of',
      generatedOn: 'Generated on',
      generatedBy: 'Generated by',
      author: 'Author',
      department: 'Department',
      approvedBy: 'Approved by',
      
      // Chart labels
      revenue: 'Revenue',
      expenses: 'Expenses',
      profit: 'Profit',
      growth: 'Growth',
      target: 'Target',
      actual: 'Actual',
      forecast: 'Forecast',
      budget: 'Budget'
    }
  };

  /**
   * Generate a complete report
   */
  async generateReport(
    type{{#if typescript}}: ReportType{{/if}},
    data{{#if typescript}}: ReportData{{/if}}
  ){{#if typescript}}: Promise<Buffer>{{/if}} {
    // Create PDF document
    const pdfDoc = await PDFDocument.create();
    
    // Embed fonts
    const helvetica = await pdfDoc.embedFont(StandardFonts.Helvetica);
    const helveticaBold = await pdfDoc.embedFont(StandardFonts.HelveticaBold);
    const courier = await pdfDoc.embedFont(StandardFonts.Courier);
    
    // Set document properties
    pdfDoc.setTitle(data.title);
    pdfDoc.setAuthor(data.metadata.author);
    pdfDoc.setSubject(this.translate(type + 'Report', data.metadata.language));
    pdfDoc.setKeywords([type, 'report', data.company.name, '{{projectName}}']);
    pdfDoc.setCreator('{{projectName}} Report Generator');
    pdfDoc.setProducer(data.company.name);
    pdfDoc.setCreationDate(new Date());
    pdfDoc.setModificationDate(new Date());
    
    // Add cover page
    await this.createCoverPage(pdfDoc, data, helvetica, helveticaBold);
    
    // Add table of contents if more than 3 sections
    if (data.sections.length > 3) {
      this.createTableOfContents(pdfDoc, data, helvetica, helveticaBold);
    }
    
    // Add content sections
    for (const [index, section] of data.sections.entries()) {
      await this.createSection(pdfDoc, section, index + 1, data, helvetica, helveticaBold, courier);
    }
    
    // Add appendices if any
    if (data.appendices?.length) {
      for (const appendix of data.appendices) {
        await this.createAppendix(pdfDoc, appendix, data, helvetica, helveticaBold);
      }
    }
    
    // Add page numbers and headers
    this.addPageNumbersAndHeaders(pdfDoc, data, helvetica);
    
    // Save and return PDF
    const pdfBytes = await pdfDoc.save();
    return Buffer.from(pdfBytes);
  }

  /**
   * Create cover page
   */
  private async createCoverPage(
    pdfDoc{{#if typescript}}: PDFDocument{{/if}},
    data{{#if typescript}}: ReportData{{/if}},
    font{{#if typescript}}: any{{/if}},
    boldFont{{#if typescript}}: any{{/if}}
  ){{#if typescript}}: Promise<void>{{/if}} {
    const page = pdfDoc.addPage([595, 842]); // A4
    const { width, height } = page.getSize();
    const centerX = width / 2;
    let y = height - 100;
    
    // Add company logo if provided
    if (data.company.logo) {
      try {
        const logoImage = await pdfDoc.embedPng(Buffer.from(data.company.logo, 'base64'));
        const logoSize = 100;
        page.drawImage(logoImage, {
          x: centerX - logoSize / 2,
          y: y - logoSize,
          width: logoSize,
          height: logoSize
        });
        y -= logoSize + 50;
      } catch (error) {
        console.warn('Failed to embed logo:', error);
      }
    }
    
    // Company name
    const companyNameWidth = boldFont.widthOfTextAtSize(data.company.name, 24);
    page.drawText(data.company.name, {
      x: centerX - companyNameWidth / 2,
      y: y,
      size: 24,
      font: boldFont,
      color: rgb(0.1, 0.2, 0.4)
    });
    y -= 80;
    
    // Report type
    const reportType = this.translate(data.type + 'Report', data.metadata.language);
    const reportTypeWidth = boldFont.widthOfTextAtSize(reportType, 32);
    page.drawText(reportType, {
      x: centerX - reportTypeWidth / 2,
      y: y,
      size: 32,
      font: boldFont,
      color: rgb(0, 0, 0)
    });
    y -= 50;
    
    // Report title
    const titleWidth = boldFont.widthOfTextAtSize(data.title, 20);
    page.drawText(data.title, {
      x: centerX - titleWidth / 2,
      y: y,
      size: 20,
      font: boldFont,
      color: rgb(0.2, 0.2, 0.2)
    });
    y -= 40;
    
    // Subtitle if exists
    if (data.subtitle) {
      const subtitleWidth = font.widthOfTextAtSize(data.subtitle, 16);
      page.drawText(data.subtitle, {
        x: centerX - subtitleWidth / 2,
        y: y,
        size: 16,
        font: font,
        color: rgb(0.4, 0.4, 0.4)
      });
      y -= 60;
    }
    
    // Period
    const periodText = `${this.translate('period', data.metadata.language)}: ${this.formatDate(data.period.from, data.metadata.language)} - ${this.formatDate(data.period.to, data.metadata.language)}`;
    const periodWidth = font.widthOfTextAtSize(periodText, 14);
    page.drawText(periodText, {
      x: centerX - periodWidth / 2,
      y: y,
      size: 14,
      font: font,
      color: rgb(0, 0, 0)
    });
    
    // Confidentiality marking
    if (data.metadata.confidentiality !== 'public') {
      const confidentialText = this.translate(data.metadata.confidentiality, data.metadata.language).toUpperCase();
      const confidentialWidth = boldFont.widthOfTextAtSize(confidentialText, 14);
      
      // Draw box around confidentiality text
      const padding = 10;
      page.drawRectangle({
        x: centerX - confidentialWidth / 2 - padding,
        y: 120 - padding / 2,
        width: confidentialWidth + padding * 2,
        height: 25,
        borderColor: rgb(0.8, 0, 0),
        borderWidth: 2
      });
      
      page.drawText(confidentialText, {
        x: centerX - confidentialWidth / 2,
        y: 125,
        size: 14,
        font: boldFont,
        color: rgb(0.8, 0, 0)
      });
    }
    
    // Footer with metadata
    const footerY = 80;
    const footerItems = [
      `${this.translate('author', data.metadata.language)}: ${data.metadata.author}`,
      data.metadata.department ? `${this.translate('department', data.metadata.language)}: ${data.metadata.department}` : null,
      `${this.translate('generatedOn', data.metadata.language)}: ${this.formatDate(new Date(), data.metadata.language)}`,
      `${this.translate('generatedBy', data.metadata.language)}: {{projectName}}`
    ].filter(Boolean);
    
    footerItems.forEach((item, index) => {
      if (item) {
        const itemWidth = font.widthOfTextAtSize(item, 10);
        page.drawText(item, {
          x: centerX - itemWidth / 2,
          y: footerY - (index * 15),
          size: 10,
          font: font,
          color: rgb(0.5, 0.5, 0.5)
        });
      }
    });
  }

  /**
   * Create table of contents
   */
  private createTableOfContents(
    pdfDoc{{#if typescript}}: PDFDocument{{/if}},
    data{{#if typescript}}: ReportData{{/if}},
    font{{#if typescript}}: any{{/if}},
    boldFont{{#if typescript}}: any{{/if}}
  ) {
    const page = pdfDoc.addPage([595, 842]);
    const { width, height } = page.getSize();
    let y = height - 100;
    
    // Title
    page.drawText('Innholdsfortegnelse', {
      x: 50,
      y: y,
      size: 24,
      font: boldFont,
      color: rgb(0, 0, 0)
    });
    y -= 50;
    
    // Section entries
    data.sections.forEach((section, index) => {
      const pageNum = index + 3; // After cover and TOC
      const title = `${index + 1}. ${section.title}`;
      
      // Draw title
      page.drawText(title, {
        x: 50,
        y: y,
        size: 12,
        font: font,
        color: rgb(0, 0, 0)
      });
      
      // Draw dots
      const titleWidth = font.widthOfTextAtSize(title, 12);
      const pageNumText = pageNum.toString();
      const pageNumWidth = font.widthOfTextAtSize(pageNumText, 12);
      const dotsStart = 50 + titleWidth + 5;
      const dotsEnd = width - 50 - pageNumWidth - 5;
      const dotSpacing = 5;
      
      for (let x = dotsStart; x < dotsEnd; x += dotSpacing) {
        page.drawText('.', {
          x: x,
          y: y,
          size: 12,
          font: font,
          color: rgb(0.5, 0.5, 0.5)
        });
      }
      
      // Draw page number
      page.drawText(pageNumText, {
        x: width - 50 - pageNumWidth,
        y: y,
        size: 12,
        font: font,
        color: rgb(0, 0, 0)
      });
      
      y -= 25;
    });
  }

  /**
   * Create content section
   */
  private async createSection(
    pdfDoc{{#if typescript}}: PDFDocument{{/if}},
    section{{#if typescript}}: ReportSection{{/if}},
    sectionNumber{{#if typescript}}: number{{/if}},
    data{{#if typescript}}: ReportData{{/if}},
    font{{#if typescript}}: any{{/if}},
    boldFont{{#if typescript}}: any{{/if}},
    monoFont{{#if typescript}}: any{{/if}}
  ){{#if typescript}}: Promise<void>{{/if}} {
    const page = pdfDoc.addPage([595, 842]);
    const { width, height } = page.getSize();
    const margins = { top: 80, bottom: 60, left: 50, right: 50 };
    let y = height - margins.top;
    
    // Section header
    page.drawText(`${sectionNumber}. ${section.title}`, {
      x: margins.left,
      y: y,
      size: 20,
      font: boldFont,
      color: rgb(0.1, 0.2, 0.4)
    });
    y -= 40;
    
    // Section description if exists
    if (section.description) {
      y = this.drawWrappedText(page, section.description, font, margins, y, width, 11, rgb(0.3, 0.3, 0.3));
      y -= 20;
    }
    
    // Render content based on type
    switch (section.type) {
      case 'text':
        y = this.renderTextContent(page, section.data, font, margins, y, width);
        break;
        
      case 'table':
        y = this.renderTableContent(page, section.data, font, boldFont, margins, y, width);
        break;
        
      case 'chart':
        y = await this.renderChartContent(pdfDoc, page, section.data, margins, y, width);
        break;
        
      case 'summary':
        y = this.renderSummaryContent(page, section.data, font, boldFont, margins, y, width, data.metadata.language);
        break;
        
      case 'list':
        y = this.renderListContent(page, section.data, font, margins, y);
        break;
        
      case 'code':
        y = this.renderCodeContent(page, section.data, monoFont, margins, y, width);
        break;
    }
  }

  /**
   * Render text content
   */
  private renderTextContent(
    page{{#if typescript}}: any{{/if}},
    content{{#if typescript}}: string | string[]{{/if}},
    font{{#if typescript}}: any{{/if}},
    margins{{#if typescript}}: any{{/if}},
    startY{{#if typescript}}: number{{/if}},
    pageWidth{{#if typescript}}: number{{/if}}
  ){{#if typescript}}: number{{/if}} {
    const paragraphs = Array.isArray(content) ? content : [content];
    let y = startY;
    
    paragraphs.forEach(paragraph => {
      y = this.drawWrappedText(page, paragraph, font, margins, y, pageWidth, 11, rgb(0, 0, 0));
      y -= 15; // Paragraph spacing
    });
    
    return y;
  }

  /**
   * Render table content
   */
  private renderTableContent(
    page{{#if typescript}}: any{{/if}},
    tableData{{#if typescript}}: TableData{{/if}},
    font{{#if typescript}}: any{{/if}},
    boldFont{{#if typescript}}: any{{/if}},
    margins{{#if typescript}}: any{{/if}},
    startY{{#if typescript}}: number{{/if}},
    pageWidth{{#if typescript}}: number{{/if}}
  ){{#if typescript}}: number{{/if}} {
    let y = startY;
    const cellPadding = 5;
    const rowHeight = 25;
    const tableWidth = pageWidth - margins.left - margins.right;
    const columnWidth = tableWidth / tableData.headers.length;
    
    // Draw header row
    page.drawRectangle({
      x: margins.left,
      y: y - rowHeight,
      width: tableWidth,
      height: rowHeight,
      color: rgb(0.9, 0.9, 0.95)
    });
    
    tableData.headers.forEach((header, index) => {
      const x = margins.left + (index * columnWidth) + cellPadding;
      page.drawText(header, {
        x: x,
        y: y - rowHeight + cellPadding + 5,
        size: 10,
        font: boldFont,
        color: rgb(0, 0, 0),
        maxWidth: columnWidth - cellPadding * 2
      });
    });
    
    y -= rowHeight;
    
    // Draw data rows
    tableData.rows.forEach((row, rowIndex) => {
      // Alternate row coloring
      if (rowIndex % 2 === 1) {
        page.drawRectangle({
          x: margins.left,
          y: y - rowHeight,
          width: tableWidth,
          height: rowHeight,
          color: rgb(0.97, 0.97, 0.97)
        });
      }
      
      // Draw borders
      page.drawLine({
        start: { x: margins.left, y: y },
        end: { x: margins.left + tableWidth, y: y },
        thickness: 0.5,
        color: rgb(0.8, 0.8, 0.8)
      });
      
      row.forEach((cell, cellIndex) => {
        const x = margins.left + (cellIndex * columnWidth) + cellPadding;
        const text = this.formatCellValue(cell, tableData.headers[cellIndex]);
        
        page.drawText(text, {
          x: x,
          y: y - rowHeight + cellPadding + 5,
          size: 9,
          font: font,
          color: rgb(0, 0, 0),
          maxWidth: columnWidth - cellPadding * 2
        });
      });
      
      y -= rowHeight;
    });
    
    // Draw footer if exists
    if (tableData.footer) {
      // Draw separator
      page.drawLine({
        start: { x: margins.left, y: y },
        end: { x: margins.left + tableWidth, y: y },
        thickness: 2,
        color: rgb(0.4, 0.4, 0.4)
      });
      
      y -= 5;
      
      // Draw footer row
      page.drawRectangle({
        x: margins.left,
        y: y - rowHeight,
        width: tableWidth,
        height: rowHeight,
        color: rgb(0.85, 0.85, 0.9)
      });
      
      tableData.footer.forEach((cell, index) => {
        const x = margins.left + (index * columnWidth) + cellPadding;
        const text = this.formatCellValue(cell, tableData.headers[index]);
        
        page.drawText(text, {
          x: x,
          y: y - rowHeight + cellPadding + 5,
          size: 10,
          font: boldFont,
          color: rgb(0, 0, 0),
          maxWidth: columnWidth - cellPadding * 2
        });
      });
      
      y -= rowHeight;
    }
    
    return y - 20;
  }

  /**
   * Render chart content
   */
  private async renderChartContent(
    pdfDoc{{#if typescript}}: PDFDocument{{/if}},
    page{{#if typescript}}: any{{/if}},
    chartData{{#if typescript}}: ChartData{{/if}},
    margins{{#if typescript}}: any{{/if}},
    startY{{#if typescript}}: number{{/if}},
    pageWidth{{#if typescript}}: number{{/if}}
  ){{#if typescript}}: Promise<number>{{/if}} {
    const chartWidth = Math.min(500, pageWidth - margins.left - margins.right);
    const chartHeight = 350;
    
    // Create canvas
    const canvas = createCanvas(chartWidth, chartHeight);
    const ctx = canvas.getContext('2d');
    
    // Configure chart
    const chartConfig = {
      type: chartData.type,
      data: {
        labels: chartData.labels,
        datasets: chartData.datasets.map(dataset => ({
          ...dataset,
          borderWidth: dataset.borderWidth || 2,
          backgroundColor: dataset.backgroundColor || this.generateColors(chartData.labels.length),
          borderColor: dataset.borderColor || this.generateColors(chartData.labels.length, 0.8)
        }))
      },
      options: {
        responsive: false,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            position: 'bottom' as const,
            labels: {
              padding: 15,
              font: {
                size: 12
              }
            }
          },
          title: {
            display: !!chartData.title,
            text: chartData.title,
            font: {
              size: 16,
              weight: 'bold'
            }
          }
        },
        scales: chartData.type === 'pie' || chartData.type === 'doughnut' ? {} : {
          y: {
            beginAtZero: true,
            grid: {
              color: 'rgba(0, 0, 0, 0.1)'
            }
          },
          x: {
            grid: {
              display: false
            }
          }
        },
        ...chartData.options
      }
    };
    
    // Render chart
    new Chart(ctx as any, chartConfig as any);
    
    // Embed chart in PDF
    const chartImage = await pdfDoc.embedPng(canvas.toBuffer('image/png'));
    const x = margins.left + (pageWidth - margins.left - margins.right - chartWidth) / 2;
    
    page.drawImage(chartImage, {
      x: x,
      y: startY - chartHeight,
      width: chartWidth,
      height: chartHeight
    });
    
    return startY - chartHeight - 40;
  }

  /**
   * Render summary content
   */
  private renderSummaryContent(
    page{{#if typescript}}: any{{/if}},
    summaryData{{#if typescript}}: Record<string, any>{{/if}},
    font{{#if typescript}}: any{{/if}},
    boldFont{{#if typescript}}: any{{/if}},
    margins{{#if typescript}}: any{{/if}},
    startY{{#if typescript}}: number{{/if}},
    pageWidth{{#if typescript}}: number{{/if}},
    language{{#if typescript}}: string{{/if}}
  ){{#if typescript}}: number{{/if}} {
    let y = startY;
    const boxesPerRow = 3;
    const boxSpacing = 15;
    const availableWidth = pageWidth - margins.left - margins.right;
    const boxWidth = (availableWidth - (boxSpacing * (boxesPerRow - 1))) / boxesPerRow;
    const boxHeight = 90;
    
    const entries = Object.entries(summaryData);
    const rows = Math.ceil(entries.length / boxesPerRow);
    
    for (let row = 0; row < rows; row++) {
      for (let col = 0; col < boxesPerRow; col++) {
        const index = row * boxesPerRow + col;
        if (index >= entries.length) break;
        
        const [key, value] = entries[index];
        const x = margins.left + (col * (boxWidth + boxSpacing));
        const boxY = y - boxHeight;
        
        // Draw box with gradient effect
        page.drawRectangle({
          x: x,
          y: boxY,
          width: boxWidth,
          height: boxHeight,
          color: rgb(0.98, 0.98, 1),
          borderColor: rgb(0.8, 0.8, 0.9),
          borderWidth: 1
        });
        
        // Draw icon area
        page.drawRectangle({
          x: x,
          y: boxY + boxHeight - 30,
          width: boxWidth,
          height: 30,
          color: rgb(0.9, 0.9, 0.95)
        });
        
        // Draw label
        const label = this.translate(key, language) || this.humanize(key);
        page.drawText(label, {
          x: x + 10,
          y: boxY + boxHeight - 22,
          size: 9,
          font: font,
          color: rgb(0.4, 0.4, 0.4),
          maxWidth: boxWidth - 20
        });
        
        // Draw value
        const formattedValue = this.formatSummaryValue(value, key);
        const valueSize = formattedValue.length > 10 ? 14 : 18;
        page.drawText(formattedValue, {
          x: x + 10,
          y: boxY + 25,
          size: valueSize,
          font: boldFont,
          color: rgb(0, 0, 0),
          maxWidth: boxWidth - 20
        });
        
        // Draw trend if exists
        if (value.trend) {
          const trendColor = value.trend > 0 ? rgb(0, 0.7, 0) : rgb(0.8, 0, 0);
          const trendSymbol = value.trend > 0 ? '↑' : '↓';
          const trendText = `${trendSymbol} ${Math.abs(value.trend)}%`;
          
          page.drawText(trendText, {
            x: x + boxWidth - 40,
            y: boxY + 10,
            size: 10,
            font: font,
            color: trendColor
          });
        }
      }
      
      y -= boxHeight + boxSpacing;
    }
    
    return y - 20;
  }

  /**
   * Helper methods
   */
  
  private drawWrappedText(
    page{{#if typescript}}: any{{/if}},
    text{{#if typescript}}: string{{/if}},
    font{{#if typescript}}: any{{/if}},
    margins{{#if typescript}}: any{{/if}},
    startY{{#if typescript}}: number{{/if}},
    pageWidth{{#if typescript}}: number{{/if}},
    fontSize{{#if typescript}}: number{{/if}},
    color{{#if typescript}}: any{{/if}}
  ){{#if typescript}}: number{{/if}} {
    const maxWidth = pageWidth - margins.left - margins.right;
    const words = text.split(' ');
    let line = '';
    let y = startY;
    
    for (const word of words) {
      const testLine = line + word + ' ';
      const testWidth = font.widthOfTextAtSize(testLine, fontSize);
      
      if (testWidth > maxWidth && line !== '') {
        page.drawText(line.trim(), {
          x: margins.left,
          y: y,
          size: fontSize,
          font: font,
          color: color
        });
        y -= fontSize + 5;
        line = word + ' ';
      } else {
        line = testLine;
      }
    }
    
    if (line.trim()) {
      page.drawText(line.trim(), {
        x: margins.left,
        y: y,
        size: fontSize,
        font: font,
        color: color
      });
      y -= fontSize + 5;
    }
    
    return y;
  }

  private formatDate(date{{#if typescript}}: Date{{/if}}, language{{#if typescript}}: string{{/if}}){{#if typescript}}: string{{/if}} {
    const locale = language === 'nb' ? 'nb-NO' : language === 'nn' ? 'nn-NO' : 'en-US';
    return new Intl.DateTimeFormat(locale, {
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    }).format(date);
  }

  private formatCellValue(value{{#if typescript}}: any{{/if}}, header{{#if typescript}}: string{{/if}}){{#if typescript}}: string{{/if}} {
    if (value === null || value === undefined) return '-';
    
    if (typeof value === 'number') {
      if (header.toLowerCase().includes('amount') || 
          header.toLowerCase().includes('beløp') ||
          header.toLowerCase().includes('sum') ||
          header.toLowerCase().includes('total')) {
        return new Intl.NumberFormat('nb-NO', {
          style: 'currency',
          currency: 'NOK'
        }).format(value);
      }
      
      if (header.includes('%') || header.toLowerCase().includes('rate')) {
        return `${value.toFixed(1)}%`;
      }
      
      return new Intl.NumberFormat('nb-NO').format(value);
    }
    
    if (value instanceof Date) {
      return this.formatDate(value, 'nb');
    }
    
    return String(value);
  }

  private formatSummaryValue(value{{#if typescript}}: any{{/if}}, key{{#if typescript}}: string{{/if}}){{#if typescript}}: string{{/if}} {
    if (typeof value === 'object' && value.value !== undefined) {
      return this.formatSummaryValue(value.value, key);
    }
    
    if (typeof value === 'number') {
      if (key.toLowerCase().includes('amount') || 
          key.toLowerCase().includes('total') ||
          key.toLowerCase().includes('revenue') ||
          key.toLowerCase().includes('expense')) {
        return new Intl.NumberFormat('nb-NO', {
          style: 'currency',
          currency: 'NOK',
          minimumFractionDigits: 0,
          maximumFractionDigits: 0
        }).format(value);
      }
      
      if (key.includes('%') || key.toLowerCase().includes('rate')) {
        return `${value.toFixed(1)}%`;
      }
      
      if (value > 1000000) {
        return `${(value / 1000000).toFixed(1)}M`;
      }
      
      if (value > 1000) {
        return `${(value / 1000).toFixed(1)}K`;
      }
      
      return new Intl.NumberFormat('nb-NO').format(value);
    }
    
    return String(value);
  }

  private translate(key{{#if typescript}}: string{{/if}}, language{{#if typescript}}: string{{/if}}){{#if typescript}}: string{{/if}} {
    const lang = language || 'nb';
    return this.translations[lang]?.[key] || this.translations['nb']?.[key] || key;
  }

  private humanize(str{{#if typescript}}: string{{/if}}){{#if typescript}}: string{{/if}} {
    return str
      .replace(/([A-Z])/g, ' $1')
      .replace(/_/g, ' ')
      .trim()
      .replace(/\b\w/g, l => l.toUpperCase());
  }

  private generateColors(count{{#if typescript}}: number{{/if}}, alpha{{#if typescript}}: number{{/if}} = 1){{#if typescript}}: string[]{{/if}} {
    const colors = [
      `rgba(54, 162, 235, ${alpha})`,
      `rgba(255, 99, 132, ${alpha})`,
      `rgba(255, 206, 86, ${alpha})`,
      `rgba(75, 192, 192, ${alpha})`,
      `rgba(153, 102, 255, ${alpha})`,
      `rgba(255, 159, 64, ${alpha})`,
      `rgba(199, 199, 199, ${alpha})`,
      `rgba(83, 102, 255, ${alpha})`,
      `rgba(255, 99, 255, ${alpha})`,
      `rgba(99, 255, 132, ${alpha})`
    ];
    
    return colors.slice(0, count);
  }

  private addPageNumbersAndHeaders(
    pdfDoc{{#if typescript}}: PDFDocument{{/if}},
    data{{#if typescript}}: ReportData{{/if}},
    font{{#if typescript}}: any{{/if}}
  ) {
    const pages = pdfDoc.getPages();
    const totalPages = pages.length;
    
    pages.forEach((page, index) => {
      if (index === 0) return; // Skip cover page
      
      const { width, height } = page.getSize();
      const pageNumber = index + 1;
      
      // Header
      page.drawLine({
        start: { x: 50, y: height - 40 },
        end: { x: width - 50, y: height - 40 },
        thickness: 0.5,
        color: rgb(0.8, 0.8, 0.8)
      });
      
      page.drawText(data.company.name, {
        x: 50,
        y: height - 35,
        size: 8,
        font: font,
        color: rgb(0.5, 0.5, 0.5)
      });
      
      const headerDate = this.formatDate(new Date(), data.metadata.language);
      const dateWidth = font.widthOfTextAtSize(headerDate, 8);
      page.drawText(headerDate, {
        x: width - 50 - dateWidth,
        y: height - 35,
        size: 8,
        font: font,
        color: rgb(0.5, 0.5, 0.5)
      });
      
      // Footer
      page.drawLine({
        start: { x: 50, y: 40 },
        end: { x: width - 50, y: 40 },
        thickness: 0.5,
        color: rgb(0.8, 0.8, 0.8)
      });
      
      // Page number
      const pageText = `${this.translate('page', data.metadata.language)} ${pageNumber} ${this.translate('of', data.metadata.language)} ${totalPages}`;
      const pageTextWidth = font.widthOfTextAtSize(pageText, 8);
      page.drawText(pageText, {
        x: (width - pageTextWidth) / 2,
        y: 25,
        size: 8,
        font: font,
        color: rgb(0.5, 0.5, 0.5)
      });
      
      // Confidentiality marking on each page
      if (data.metadata.confidentiality !== 'public') {
        const confidentialText = this.translate(data.metadata.confidentiality, data.metadata.language);
        page.drawText(confidentialText, {
          x: 50,
          y: 25,
          size: 8,
          font: font,
          color: rgb(0.7, 0, 0)
        });
      }
    });
  }
}

// Export generator instance
export const reportGenerator = new ReportGenerator();