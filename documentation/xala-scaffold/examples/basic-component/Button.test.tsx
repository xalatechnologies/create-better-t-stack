/**
 * Example: Button Component Tests
 * 
 * Comprehensive test suite demonstrating testing patterns for
 * Norwegian compliance, accessibility, and enterprise standards.
 * 
 * Generated by: xala-scaffold generate component Button --tests --compliance --accessibility
 */

import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { axe, toHaveNoViolations } from 'jest-axe';
import userEvent from '@testing-library/user-event';
import { Button, ButtonProps } from './Button';
import { setupNorwegianComplianceTesting } from '@xala/scaffold/testing';
import { NSMClassification } from '@/types/compliance';

// Extend Jest matchers
expect.extend(toHaveNoViolations);

describe('Button Component', () => {
  let testingUtils: any;
  
  beforeAll(async () => {
    testingUtils = await setupNorwegianComplianceTesting({
      classification: 'OPEN',
      locale: 'nb-NO',
      framework: 'jest'
    });
  });
  
  afterAll(async () => {
    await testingUtils.cleanup();
  });
  
  // Test helpers
  const renderButton = (props: Partial<ButtonProps> = {}) => {
    const defaultProps: ButtonProps = {
      children: 'Test Button',
      ...props,
    };
    
    return render(<Button {...defaultProps} />);
  };

  describe('Rendering', () => {
    test('renders with default props', () => {
      renderButton();
      
      const button = screen.getByRole('button', { name: /test button/i });
      expect(button).toBeInTheDocument();
      expect(button).toHaveClass('bg-blue-600'); // Primary variant default
      expect(button).toHaveClass('h-10'); // Medium size default
    });
    
    test('renders with custom text', () => {
      renderButton({ children: 'Klikk her' });
      
      expect(screen.getByRole('button', { name: /klikk her/i })).toBeInTheDocument();
    });
    
    test('renders with different variants', () => {
      const variants: Array<ButtonProps['variant']> = ['primary', 'secondary', 'destructive', 'ghost'];
      
      variants.forEach((variant) => {
        const { unmount } = renderButton({ variant, children: `${variant} button` });
        
        const button = screen.getByRole('button');
        
        switch (variant) {
          case 'primary':
            expect(button).toHaveClass('bg-blue-600');
            break;
          case 'secondary':
            expect(button).toHaveClass('bg-gray-100');
            break;
          case 'destructive':
            expect(button).toHaveClass('bg-red-600');
            break;
          case 'ghost':
            expect(button).toHaveClass('bg-transparent');
            break;
        }
        
        unmount();
      });
    });
    
    test('renders with different sizes', () => {
      const sizes: Array<ButtonProps['size']> = ['small', 'medium', 'large'];
      
      sizes.forEach((size) => {
        const { unmount } = renderButton({ size, children: `${size} button` });
        
        const button = screen.getByRole('button');
        
        switch (size) {
          case 'small':
            expect(button).toHaveClass('h-8');
            break;
          case 'medium':
            expect(button).toHaveClass('h-10');
            break;
          case 'large':
            expect(button).toHaveClass('h-12');
            break;
        }
        
        unmount();
      });
    });
    
    test('renders full width when specified', () => {
      renderButton({ fullWidth: true });
      
      const button = screen.getByRole('button');
      expect(button).toHaveClass('w-full');
    });
    
    test('renders loading state', () => {
      renderButton({ loading: true });
      
      const button = screen.getByRole('button');
      expect(button).toHaveAttribute('aria-busy', 'true');
      expect(button).toBeDisabled();
      expect(screen.getByText(/laster/i)).toBeInTheDocument(); // Norwegian "loading"
      
      // Check for loading spinner
      const spinner = button.querySelector('svg');
      expect(spinner).toBeInTheDocument();
      expect(spinner).toHaveClass('animate-spin');
    });
    
    test('renders disabled state', () => {
      renderButton({ disabled: true });
      
      const button = screen.getByRole('button');
      expect(button).toBeDisabled();
      expect(button).toHaveAttribute('aria-disabled', 'true');
      expect(button).toHaveClass('opacity-50', 'cursor-not-allowed');
    });
  });

  describe('Interactions', () => {
    test('calls onClick when clicked', async () => {
      const handleClick = jest.fn();
      renderButton({ onClick: handleClick });
      
      const button = screen.getByRole('button');
      await userEvent.click(button);
      
      expect(handleClick).toHaveBeenCalledTimes(1);
      expect(handleClick).toHaveBeenCalledWith(expect.any(Object));
    });
    
    test('does not call onClick when disabled', async () => {
      const handleClick = jest.fn();
      renderButton({ onClick: handleClick, disabled: true });
      
      const button = screen.getByRole('button');
      await userEvent.click(button);
      
      expect(handleClick).not.toHaveBeenCalled();
    });
    
    test('does not call onClick when loading', async () => {
      const handleClick = jest.fn();
      renderButton({ onClick: handleClick, loading: true });
      
      const button = screen.getByRole('button');
      await userEvent.click(button);
      
      expect(handleClick).not.toHaveBeenCalled();
    });
    
    test('supports keyboard navigation', async () => {
      const handleClick = jest.fn();
      renderButton({ onClick: handleClick });
      
      const button = screen.getByRole('button');
      button.focus();
      
      expect(button).toHaveFocus();
      
      // Test Enter key
      await userEvent.keyboard('{Enter}');
      expect(handleClick).toHaveBeenCalledTimes(1);
      
      // Test Space key
      await userEvent.keyboard(' ');
      expect(handleClick).toHaveBeenCalledTimes(2);
    });
  });

  describe('Norwegian Compliance', () => {
    test('has correct NSM classification attribute', () => {
      renderButton({ classification: NSMClassification.RESTRICTED });
      
      const button = screen.getByRole('button');
      expect(button).toHaveAttribute('data-nsm-classification', 'RESTRICTED');
    });
    
    test('logs audit information for restricted classifications', async () => {
      const auditLogger = testingUtils.mockGenerator.getMock('auditLogger');
      const handleClick = jest.fn();
      
      renderButton({ 
        classification: NSMClassification.RESTRICTED,
        onClick: handleClick,
        variant: 'destructive'
      });
      
      const button = screen.getByRole('button');
      await userEvent.click(button);
      
      expect(auditLogger.log).toHaveBeenCalledWith({
        action: 'button_click',
        resource: 'Button',
        classification: NSMClassification.RESTRICTED,
        metadata: {
          variant: 'destructive',
          size: 'medium',
          locale: 'nb-NO',
          timestamp: expect.any(String),
        },
      });
    });
    
    test('does not log audit information for open classification', async () => {
      const auditLogger = testingUtils.mockGenerator.getMock('auditLogger');
      const handleClick = jest.fn();
      
      renderButton({ 
        classification: NSMClassification.OPEN,
        onClick: handleClick
      });
      
      const button = screen.getByRole('button');
      await userEvent.click(button);
      
      expect(auditLogger.log).not.toHaveBeenCalled();
    });
    
    test('has Norwegian language attribute', () => {
      renderButton();
      
      const button = screen.getByRole('button');
      expect(button).toHaveAttribute('lang', 'nb-NO');
    });
  });

  describe('Accessibility (WCAG AAA)', () => {
    test('has no accessibility violations', async () => {
      const { container } = renderButton();
      
      const results = await axe(container);
      expect(results).toHaveNoViolations();
    });
    
    test('has proper ARIA attributes', () => {
      renderButton({ 
        ariaLabel: 'Lagre endringer',
        ariaDescribedBy: 'save-help'
      });
      
      const button = screen.getByRole('button');
      expect(button).toHaveAttribute('aria-label', 'Lagre endringer');
      expect(button).toHaveAttribute('aria-describedby', 'save-help');
    });
    
    test('has proper focus indicators', () => {
      renderButton();
      
      const button = screen.getByRole('button');
      expect(button).toHaveClass('focus:outline-none', 'focus:ring-2', 'focus:ring-offset-2');
      expect(button).toHaveClass('focus-visible:ring-2', 'focus-visible:ring-offset-2');
    });
    
    test('meets color contrast requirements', () => {
      // Test different variants for contrast
      const variants: Array<{ variant: ButtonProps['variant']; textColor: string; bgColor: string }> = [
        { variant: 'primary', textColor: 'white', bgColor: 'blue-600' },
        { variant: 'destructive', textColor: 'white', bgColor: 'red-600' },
        { variant: 'secondary', textColor: 'gray-900', bgColor: 'gray-100' },
      ];
      
      variants.forEach(({ variant, textColor, bgColor }) => {
        const { unmount } = renderButton({ variant });
        
        const button = screen.getByRole('button');
        expect(button).toHaveClass(`text-${textColor}`, `bg-${bgColor}`);
        
        // In a real implementation, you would calculate actual contrast ratios
        // For WCAG AAA, contrast ratio should be at least 7:1
        
        unmount();
      });
    });
    
    test('supports screen readers with proper button role', () => {
      renderButton({ children: 'Klikk her' });
      
      // Button should be discoverable by screen readers
      const button = screen.getByRole('button', { name: /klikk her/i });
      expect(button).toBeInTheDocument();
      
      // Should have proper button semantics
      expect(button.tagName).toBe('BUTTON');
    });
    
    test('loading state is announced to screen readers', () => {
      renderButton({ loading: true });
      
      const button = screen.getByRole('button');
      expect(button).toHaveAttribute('aria-busy', 'true');
      
      // Loading text should be accessible
      expect(screen.getByText(/laster/i)).toBeInTheDocument();
    });
    
    test('disabled state is announced to screen readers', () => {
      renderButton({ disabled: true });
      
      const button = screen.getByRole('button');
      expect(button).toHaveAttribute('aria-disabled', 'true');
      expect(button).toBeDisabled();
    });
  });

  describe('Performance', () => {
    test('renders within performance budget', async () => {
      const { measureRenderTime } = testingUtils.testHelpers;
      
      const metrics = await measureRenderTime(() => {
        renderButton({ children: 'Performance Test' });
      }, 100);
      
      // Should render within 16ms (60fps)
      expect(metrics.average).toBeLessThan(16);
      expect(metrics.max).toBeLessThan(33); // 30fps worst case
    });
    
    test('does not cause memory leaks', async () => {
      const { getMemoryUsage } = testingUtils.testHelpers;
      
      const initialMemory = getMemoryUsage();
      
      // Render and unmount multiple times
      for (let i = 0; i < 100; i++) {
        const { unmount } = renderButton({ children: `Test ${i}` });
        unmount();
      }
      
      // Force garbage collection if available
      if (global.gc) {
        global.gc();
      }
      
      const finalMemory = getMemoryUsage();
      
      // Memory usage should not increase significantly
      const memoryIncrease = finalMemory.used - initialMemory.used;
      expect(memoryIncrease).toBeLessThan(10 * 1024 * 1024); // Less than 10MB
    });
  });

  describe('Localization', () => {
    test('displays loading text in Norwegian', () => {
      renderButton({ loading: true });
      
      // Should show Norwegian loading text
      expect(screen.getByText(/laster/i)).toBeInTheDocument();
    });
    
    test('handles Norwegian characters correctly', () => {
      renderButton({ children: 'Søk etter æøå' });
      
      const button = screen.getByRole('button', { name: /søk etter æøå/i });
      expect(button).toBeInTheDocument();
    });
    
    test('has correct text direction for Norwegian', () => {
      renderButton();
      
      const button = screen.getByRole('button');
      
      // Norwegian is LTR, should not have RTL styling
      expect(button).not.toHaveAttribute('dir', 'rtl');
      expect(button).toHaveAttribute('lang', 'nb-NO');
    });
  });

  describe('TypeScript Integration', () => {
    test('accepts all valid prop combinations', () => {
      // These should compile without TypeScript errors
      const validProps: ButtonProps[] = [
        { children: 'Test' },
        { children: 'Test', variant: 'primary' },
        { children: 'Test', size: 'large' },
        { children: 'Test', loading: true },
        { children: 'Test', disabled: true },
        { children: 'Test', fullWidth: true },
        { children: 'Test', onClick: () => {} },
        { children: 'Test', type: 'submit' },
        { children: 'Test', ariaLabel: 'Custom label' },
        { children: 'Test', className: 'custom-class' },
        { children: 'Test', 'data-testid': 'custom-test-id' },
        { children: 'Test', classification: NSMClassification.CONFIDENTIAL },
      ];
      
      validProps.forEach((props) => {
        const { unmount } = renderButton(props);
        expect(screen.getByRole('button')).toBeInTheDocument();
        unmount();
      });
    });
  });

  describe('Edge Cases', () => {
    test('handles empty children gracefully', () => {
      renderButton({ children: '' });
      
      const button = screen.getByRole('button');
      expect(button).toBeInTheDocument();
      expect(button.textContent).toBe('');
    });
    
    test('handles complex children elements', () => {
      renderButton({ 
        children: (
          <span>
            <strong>Bold</strong> and <em>italic</em>
          </span>
        )
      });
      
      const button = screen.getByRole('button');
      expect(button).toBeInTheDocument();
      expect(screen.getByText('Bold')).toBeInTheDocument();
      expect(screen.getByText('italic')).toBeInTheDocument();
    });
    
    test('handles very long text content', () => {
      const longText = 'A'.repeat(1000);
      renderButton({ children: longText });
      
      const button = screen.getByRole('button');
      expect(button).toBeInTheDocument();
      expect(button.textContent).toBe(longText);
    });
    
    test('handles rapid click events', async () => {
      const handleClick = jest.fn();
      renderButton({ onClick: handleClick });
      
      const button = screen.getByRole('button');
      
      // Simulate rapid clicking
      for (let i = 0; i < 10; i++) {
        await userEvent.click(button);
      }
      
      expect(handleClick).toHaveBeenCalledTimes(10);
    });
  });

  describe('Ref Forwarding', () => {
    test('forwards ref to button element', () => {
      const ref = React.createRef<HTMLButtonElement>();
      renderButton({ ref });
      
      expect(ref.current).toBeInstanceOf(HTMLButtonElement);
      expect(ref.current?.tagName).toBe('BUTTON');
    });
    
    test('ref can be used to focus button', () => {
      const ref = React.createRef<HTMLButtonElement>();
      renderButton({ ref });
      
      ref.current?.focus();
      expect(ref.current).toHaveFocus();
    });
  });
});

// Example of integration test
describe('Button Integration Tests', () => {
  test('integrates with form submission', async () => {
    const handleSubmit = jest.fn();
    
    render(
      <form onSubmit={handleSubmit}>
        <Button type="submit">Send inn</Button>
      </form>
    );
    
    const button = screen.getByRole('button', { name: /send inn/i });
    await userEvent.click(button);
    
    expect(handleSubmit).toHaveBeenCalledTimes(1);
  });
  
  test('integrates with Norwegian compliance system', async () => {
    const testingUtils = await setupNorwegianComplianceTesting({
      classification: 'CONFIDENTIAL',
      locale: 'nb-NO'
    });
    
    const handleClick = jest.fn();
    render(
      <Button 
        onClick={handleClick}
        classification={NSMClassification.CONFIDENTIAL}
        variant="destructive"
      >
        Slett konfidensielt innhold
      </Button>
    );
    
    const button = screen.getByRole('button');
    await userEvent.click(button);
    
    // Should log high-security button interaction
    const auditLogger = testingUtils.mockGenerator.getMock('auditLogger');
    expect(auditLogger.log).toHaveBeenCalledWith(
      expect.objectContaining({
        action: 'button_click',
        classification: NSMClassification.CONFIDENTIAL
      })
    );
    
    await testingUtils.cleanup();
  });
});